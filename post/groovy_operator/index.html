<!doctype html>
<html lang="en-us">
  <head>
    <title>Groovy Truth y nuevos operadores // Omar Aparicio</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Omar Aparicio" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://omaraparicio07.github.io/css/main.min.59023e5fd38d6ecb0e1dfbb295077c3c67e00e3b9eb3feaf34b5a5e6b332897a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Groovy Truth y nuevos operadores"/>
<meta name="twitter:description" content="Groovy truth Continuando con groovy me encontré con una caracteristica muy interesante,Groovy Truth, es como se conoce a la capacidad que tiene groovy de extender la evaluación booleana de java. Dentro de una sentencia de decisión if para poder evaluar si una cadena es vacia en java tendriamos que realizar algo similar a esto:
String strEmpty = &quot;&quot;; if(strEmpty.isEmpty()) System.out.println(&quot;cadena Vacia&quot;);  Donde se aprecia que es necesario llamar a un metodo que realice la evaluacion y de como resultado un valor booleano, ya que es el unico tipo de dato que puede evaliar java en una sentencia if mientra que groovy ya evalua por defecto una cadena vacia como falso y no es necesario llamar a ningun metodo, otros elementos que groovy evalua como falsos por defectos son los que se aprecian en la imágen"/>

    <meta property="og:title" content="Groovy Truth y nuevos operadores" />
<meta property="og:description" content="Groovy truth Continuando con groovy me encontré con una caracteristica muy interesante,Groovy Truth, es como se conoce a la capacidad que tiene groovy de extender la evaluación booleana de java. Dentro de una sentencia de decisión if para poder evaluar si una cadena es vacia en java tendriamos que realizar algo similar a esto:
String strEmpty = &quot;&quot;; if(strEmpty.isEmpty()) System.out.println(&quot;cadena Vacia&quot;);  Donde se aprecia que es necesario llamar a un metodo que realice la evaluacion y de como resultado un valor booleano, ya que es el unico tipo de dato que puede evaliar java en una sentencia if mientra que groovy ya evalua por defecto una cadena vacia como falso y no es necesario llamar a ningun metodo, otros elementos que groovy evalua como falsos por defectos son los que se aprecian en la imágen" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://omaraparicio07.github.io/post/groovy_operator/" />
<meta property="article:published_time" content="2019-06-13T10:24:07-05:00"/>
<meta property="article:modified_time" content="2019-06-13T10:24:07-05:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://omaraparicio07.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Omar Aparicio" /></a>
      <h1>Omar Aparicio</h1>
      <p>Estudiante de Ingeniería en Sistemas Computacionales en la Escuela Superior de Cómputo</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/omaraparicio07/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://gitlab.com/OmarAparicio/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-gitlab">
  <title>gitlab</title>
  <path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/OmarAparicio/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Groovy Truth y nuevos operadores</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 13, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h3 id="groovy-truth">Groovy truth</h3>

<p>Continuando con groovy me encontré con una caracteristica muy interesante,<strong>Groovy Truth</strong>, es como se conoce a la capacidad que tiene groovy de extender la evaluación booleana de java. Dentro de una sentencia de decisión <em>if</em>  para poder evaluar si una cadena es vacia en java tendriamos que realizar algo similar a esto:</p>

<pre><code class="language-java">	String strEmpty = &quot;&quot;;
	if(strEmpty.isEmpty())
		System.out.println(&quot;cadena Vacia&quot;);
</code></pre>

<p>Donde se aprecia que es necesario llamar a un metodo que realice la evaluacion y de como resultado un valor booleano, ya que es el unico tipo de dato que puede evaliar java en una sentencia <em>if</em>  mientra que groovy
ya evalua por defecto una cadena vacia como falso y no es necesario llamar a ningun metodo, otros elementos que groovy evalua como falsos por defectos son los que se aprecian en la imágen</p>

<p><img src="/groovy_truth.png" alt="goovy_truth" /></p>

<p>Esta simple pero conveniente aportación de groovy simplifica algunas de las validaciones mas comunes,
por ejemplo, en ocasiones tendremos la necesidad validar si un elemento es distinto de <strong><em>null</em></strong> y al mismo tiempo que no sea un elemento <strong><em>vacio</em></strong>, para realizar esto bastaria con colocar el elemento en la sentencia <em>if</em>
y el resultado sera <em>true</em> si cumple con ambos criterios.</p>

<h3 id="nuevos-operadores">Nuevos operadores</h3>

<p>Otra de las caracteristicas que llamo mi atención es la introducción de nuevos operadores como es el caso de <strong><em>Elvis(&ldquo;?.&rdquo;)</em></strong> el cúal es una interpretación distinta del operador ternario <strong>?:</strong> de java para la evaluación de una expresion boolena, elvis  hace uso de lo mencionado antes con groovy truth.
El operador elvis esta pensado para que solo se realice una acción si el resultado de la operación boolena es falso, como el caso de la evalación de un elemento vacio, podriamos cambiar el estado del elemento si esté resulta estar vacio.</p>

<p>La comparación de elementos utilizado en diferentes escenarios cuando se esta desarrollando cualquier tipo de aplicación, por lo que existen distintos metodos para comparar estos elementos, en java contamos con compareTo() y equals() para hacer esta comparación siempre y cuando este implementada la interfaz comparable().
sin embargo groovy es capaz de realizar las llamadas a estos metodos infiriendolos usando simplement usando el operador <strong>==</strong>.</p>

<p>Sabiendo que se groovy hace uso de los metodos compareTo () y equals() por medio del operador <strong>==</strong>, entra en escena un nuevo operador que recibe el nombre de <strong><em>spacheship</em></strong>, este operador evalua 2 elementos y devueve un valor entero que puede ser 1 , -1 ó 0, dependiendo de los elementos a evaluar.
Regresa un valor de 0 si los elementos son iguales, los valores 1 y -1 son devueltos en caso de que alguno de los operadores sea mayor que el otro de forma ascendente.
El valor 1 aplica cuando el operando de la izquierda es mayor al de la derecha y -1 en caso contrario, esto lo hace groovy de manera automatica gracias a las caracteristicas de los lenguajes dinamicos.</p>

<p>El ultimo operador que mencionare en este post es el denominado <strong><em>spreddot(&rdquo;*.&ldquo;)</em></strong>, dicho operador tiene una funcionalidad a los iterador de java para recorrer una coleccion de datos, pero de una manera mas concisa y sin requerir todos los pasos de crear un ciclo y pensar en una condicion de paro para poder obtener todos los elementos de una colección. También es muy util para la concatenación de colecciones ya va agregando elemento a elemento cuando es invocado.</p>

<p>Sigo encontrando caracteristicas interesantes en groovy y como es que hace mas digerible y amigable lo que ya se conoce se java pero sin complicar mucho las cosas al momento de realizar tareas sencillas.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
